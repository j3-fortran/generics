To: J3                                                     J3/24-163rX
From: generics
Subject: Edits for TEMPLATE construct
Date: 2024-October-22
References: 24-161, 24-162, 24-125r5, 24-126r4, 24-127r4

Introduction:
=============

This is the 3rd of 6 papers that provide edits for the approved syntax
for templates.

Note that the section numbering is merely suggestive.  The overall
ordering of template subclauses will change in future papers, and
clause 15 itself is merely a placeholder.

Section 1:
==========

* Append the following at the end of clause 15 from paper 24-162.


15.3 The TEMPLATE construct

15.3.1 Syntax for the TEMPLATE construct

A TEMPLATE construct defines a template that may define multiple
entities which may be accessed through instantiation.

R1510 <template> <<is>> <template-stmt>
                        [ <template-specification-part> ]
                        [ <template-subprogram-part> ]
                        <end-template-stmt>

C1527a (R1510) A <template> shall only appear in the <specification-part>
               of a main program or module.

R1511 <template-stmt> <<is>>
          TEMPLATE <template-name> ([<deferred-arg-list>])

R1512 <end-template-stmt> <<is>>  END TEMPLATE [<template-name>]


C1527b (R1512) If a <template-name> appears in the <end-template-stmt>,
               it shall be identical to the <template-name>
               specified in the <template-stmt>.

15.3.2 Template specification part

R1513 <template-specification-part> <<is>>
          [ <use-stmt> ] ...
          [ <import-stmt> ] ...
          [ <template-declaration-construct> ] ...

The implicit mapping within <template> is as if
       IMPLICIT NONE(TYPE,EXTERNAL)
is specified.

R1514 <template-declaration-construct>
          <<is>> <template-specification-construct>
          <<or>> <deferred-arg-decl-stmt>
          <<or>> <requirement>
          <<or>> <template>

R1515 <template-specification-construct>
          <<is>> <access-stmt>
          <<or>> <derived-type-def>
          <<or>> <dimension-stmt>
          <<or>> <enum-def>
          <<or>> <enumeration-type-def>
          <<or>> <generic-stmt>
          <<or>> <instantiate-stmt>
          <<or>> <interface-block>
          <<or>> <intrinsic-stmt>
          <<or>> <parameter-stmt>
          <<or>> <type-declaration-stmt>

C1528 (R1515) An entity declared by <type-declaration-stmt> shall have
              the PARAMETER attribute.

NOTE 1

    ALLOCATABLE, ASYNCHRONOUS, BIND, CODIMENSION, COMMON, CONTIGUOUS,
    DATA, ENTRY, EQUIVALENCE, EXTERNAL, FORMAT, INTENT, NAMELIST,
    OPTIONAL, POINTER, PROTECTED, SAVE, TARGET, VOLATILE, VALUE, or
    statement function statements cannot appear in a template
    specification section.

NOTE 2

    A template specification section cannot declare variables.

15.3.3 Template subprogram part

R1516 <template-subprogram-part> <<is>> <contains-stmt>
                                        [ <template-subprogram> ] ...

R1517 <template-subprogram>
          <<is>> <function-subprogram>
          <<or>> <subroutine-subprogram>
          <<or>> <templated-function-subprogram>
          <<or>> <templated-subroutine-subprogram>

15.4 Templated procedures

A templated procedure is a template that defines a single
procedure which is accessible via instantiation.


R1518 <templated-function-subprogram> <<is>>
          <templated-function-stmt>
          <templated-subprogram-specification-part>
          [<execution-part>]
          [<internal-subprogram-part>]
          <end-function-stmt>

C1529 (R1518) If a <function-name> appears in the <end-function-stmt>,
              it shall be identical to the <template-name>
              specified in the <templated-function-stmt>.

R1519 <templated-subroutine-subprogram> <<is>>
          <templated-subroutine-stmt>
          <templated-subprogram-specification-part>
          [<execution-part>]
          [<internal-subprogram-part>]
          <end-subroutine-stmt>

C1530 (R1519) If a <subroutine-name> appears in the <end-subroutine-stmt>,
              it shall be identical to the <template-name>
              specified in the <templated-subroutine-stmt>.

C1531 An internal templated procedure shall not contain an
      <internal-subprogram-part>.

R1520 <templated-subprogram-specification-part> <<is>>
          [ <use-stmt> ] ...
          [ <import-stmt> ] ...
          [ <templated-subprogram-declaration-construct> ] ...

R1521 <templated-subprogram-declaration-construct>
          <<is>> <deferred-arg-decl-stmt>
          <<or>> <format-stmt>
          <<or>> <specification-construct>

R1522 <templated-function-stmt> <<is>>
          [ <prefix> ] FUNCTION <template-name>
          ( <deferred-arg-list> ) ([<dummy-arg-list>])
          [<suffix>]

R1523 <templated-subroutine-stmt> <<is>>
         [ <prefix> ] SUBROUTINE <template-name>
         ( <deferred-arg-list> ) ([<dummy-arg-list>])
         [<proc-language-binding-spec>]

15.5 Restrictions on template definitions

C1533 A variable or procedure pointer declared in either a
      <template-subprogram-part> or a
      <templated-subprogram-declaration-construct> shall
      not have the SAVE attribute.

C1534 EQUIVALENCE and COMMON shall not appear in a
      <template-subprogram-part> or a
      <templated-subprogram-declaration-construct>.


C1535 <template>, <templated-function-subprogram> and
      <templated-subroutine-subprogram> shall only
      reference intrinsic procedures, procedures with explicit
      interfaces, operators, or intrinsic assignment.

NOTE

    This constraint expresses the notion of type-safety.  In particular,
    this allows a template implementation to be verified to be internally
    consistent.

===END===
