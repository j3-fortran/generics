To: J3                                                     J3/25-140
From: generics
Subject: Miscellaneous edits to incorporate templates
Date: 2025-May-19
References: 25-007r1, 25-112, 25-135, 25-136, 25-137, 25-138, 25-139,
            24-125r5, 24-126r4, 24-127r4

1. Introduction
===============

This is the 6th of 6 papers that provide edits for the approved syntax
for templates. This paper describes various edits occurring outside the
new new clause introduced in papers 1-5 that are necessary to incorporate
the syntax and semantics for templates.

2. Misc edits for templates
===========================

Clause 3:  Terms and definitions
--------------------------------

[5:5+] Insert new glossary term:

  "3.7.2b
   [deferred argument association]
   association between an instantiation argument and a deferred
   argument (Sec. ???)"

[10:9+] Insert new glossary term

  "3.34.1
  [deferred constant]
  a deferred argument with the PARAMETER attribute"


[11:32+] Insert new glossary terms

  "3.46b
   [deferred argument]
   named entity that appears in a <deferred-arg-list> (R???) (Sec. ???)"

[17:18+] Insert new glossary term

  "3.85b
  [instantiation argument]
  entity that determines deferred argument association"


[24:3] 3.120 scoping unit: Change "or subprogram" to "subprogram,
       template construct, or requirement construct", such that the
       entire definition reads

   "BLOCK construct, derived-type definition, interface body, program
   unit (3.113), subprogram, template construct, or requirement
   construct, excluding all nested scoping units in it"


[27:12] 3.139 subprogram: Change "or subroutine-subprogram (R1537)" to
        ", subroutine-subprogram (R1537), templated-function-subprogram, or
        templated-subroutine-subprogram", such that the entire
        definition now reads:

        "<function-subprogram> (R1532), <subroutine-subprogram> (R1537),
        <templated-function-subprogram> (R???), or
        <templated-subroutine-subprogram> (R???)"


[32:16+] Insert new glossary term

  "3.151b
  [ultimately defined prior]
  an entity that is accessed by host association and whose definition
  appears before the scoping unit in which it is reference or is
  ultimately defined prior in the host scoping unit"

{UTI - is this still used? TLC}

{UTI: instantiation association}

{UTI: characteristics of deferred arguments - if we use that
terminology for REQUIREMENT.}

Clause 5: Fortran concepts
--------------------------


[44:20-28] In 5.1 High level syntax, extend R508
           specification-construct to include new syntax terms:
           <template>, <require-stmt>, <requirement> and
           <instantiation-stmt>, such that it now reads:

   "R508 <specification-construct> <<is>> <derived-type-def>
                                   <<or>> <enum-def>
                                   <<or>> <enumeration-type-def>
                                   <<or>> <generic-stmt>
                                   <<or>> <interface-block>
                                   <<or>> <parameter-stmt>
                                   <<or>> <procedure-declaration-stmt>
                                   <<or>> <other-specification-stmt>
                                   <<or>> <type-declaration-stmt>
                                   <<or>> <template>
                                   <<or>> <require-stmt>
                                   <<or>> <requirement>
                                   <<or>> <instantiate-stmt>
   "

{ Allowing REQUIRE outside of templates is not something that has been
  discussed in plenary, but seems to be a natural thing to allow to
  generics subgroup.  It would provide a means for library developer
  to ensure that their product meets certain requirements without
  regard to any specific (external) template.}

[44:37-38] Extend R512 to include templated procedures such that it now reads:


   "R512 <internal-subprogram>
         <<is>> <function-subprogram>
         <<or>> <subroutine-subprogram>
         <<or>> <templated-subroutine-subprogram>
         <<or>> <templated-function-subprogram>"


* 5.3.2 Statement order

[48:1+] Update first line in table 5.1, to include TEMPLATE such that it now
reads:

   "PROGRAM, FUNCTION, SUBROUTINE, MODULE, SUBMODULE, TEMPLATE, or
    BLOCK DATA statement."

[48:9+] Add a new column to Table 5.2 Statements allowed in scoping units,
with heading "Template".  The row entries are:

   "
     - USE                   Yes
     - IMPORT                Yes
     - ENTRY                 No
     - FORMAT                No
     - Misc. decl.s(1)       Yes (2)
     - DATA                  No
     - Derived-type          Yes
     - Interface             Yes
     - Executable            No
     - CONTAINS              Yes
     - Statement function    No
    "

[48:9+]  Add a new footnote to table 2:

    "(2) Only named constants may be declared in templates."

{Note:  It is unfortunate that adding a new column may not readily fit and that a substantial redesign of Table 2 may become necessary.}


[49:2] 5.3.3 The END statement: After "module subprogram", insert ",
       templated subprogram" such that the entire sentence reads:

       "Each program unit, module subprogram, templated subprogram,
       and internal subprogram shall have exactly one END statement."

[49:7] After "end-module-statement", insert ", end-template-statement,
       end-requirement-stmt" such that the sentence now reads:

        "The end-module-stmt, end-template-statement,
        end-requirement-stmt, end-submodule-stmt, and
        end-block-data-stmt statements are nonexecutable."

* 5.4.1.1 General

[51:13] 5.4.1.1 Geeneral

  Modify first sentence of paragraph 2 to read:

  "A type is either an intrinsic type, a derived type, or a deferred type."

{UTI - this sentence is very different than what is in the standard.}

[51:27+]  Add a new subclause

  "5.4.1.3+ Deferred type

  Deferred types are deferred arguments that are types in templates,
  templated procedures, or requirements.  Deferred types are described
  further in tt.xx. "


Clause 6: Lexical tokens and source form
----------------------------------------

[62:4] 6.2.6 Delimiters
   Change  "or /)"  to  "/), {, or }." such that the entire sentence reads:

  "A lexical token that is a delimiter is a (, ), /, [, ], {, }, (/, or /)."


Clause 7: Types
---------------

[68:16-19] In section 7.3.2.1 Type specifier syntax, insert <deferred-type> in R702
           <type-spec> such that it reads:

   " R702 <type-spec> <<is>> <intrinsic-type-spec>
       <<or>> <derived-type-spec>
       <<or>> <deferred-type>
       <<or>> <enum-type-spec>
       <<or>> <enumeration-type-spec> "

[68:20] In C703, after derived-type-spec, insert 'or deferred-type' such that it reads:

  "(R702) The <derived-type-spec> or <deferred-type> shall not specify
   an abstract type (7.5.7) except when it appears as an
   <instantiation-arg>."

[68:21-30] In R703 <declaration-type-spec> insert '<<or>> TYPE ( <deferred-type> )' after 'derived-type-spec' such that R703 now reads:

    "R703 <declaration-type-spec> <<is>> <intrinsic-type-spec>
       <<or>> TYPE ( <intrinsic-type-spec> )
       <<or>> TYPE ( <derived-type-spec> )
       <<or>> TYPE ( <deferred-type> )
       <<or>> TYPE ( <enum-type-spec> )
       <<or>> TYPE ( <enumeration-type-spec> )
       <<or>> CLASS ( <derived-type-spec> )
       <<or>> CLASS ( <deferred-type> )
       <<or>> CLASS ( * )
       <<or>> TYPE ( * )
       <<or>> TYPEOF ( <data-ref> )
       <<or>> CLASSOF ( <data-ref> )"

[68:31] Change C705 wording to be consintent with constraints just after it:

  "C705 (R703) CLASS(<derived-type-spec>) shall specify an extensible
  type (7.5.7)."

{This is just a wording change, but the original is so glaringly
different than the nigh identical constraint that follows, that
generics subgroup thought it should be updated.}

[68:34+] After C705, insert a new constraint:

   "C705+ (R703) CLASS(<deferred-type>) shall specify an extensible
    type (7.5.7)."

[69:1+] After C706 introduce a new constraint

   "C706+ (R703) TYPE(<deferred-type>) shall not specify an abstract type
   (7.5.7)."

[80:27+] In 7.5.2.1 Syntax of a derived-type definition, insert a new
         constraint on R728 after C737:
 
   "C737b (R728) <parent-type-name> shall not be a <deferred-type>."


Clause 8: Attribute declarations and specifications
---------------------------------------------------

[113:15] In 8.5.2 Accessibility attribute, in C817, insert "or
         template" after "module", so that it now reads:

  "C817 An access-spec shall appear only in the specification-part of a
       module or template construct."


[118:14] In 8.5.8.1 General, change the last entry for <array-spec> from:
            "<<or>> <assumed-rank-spec>"
  to
            "<<or>>   <assumed-or-implied-rank-spec>".

[118:19] Modify R818 to disambiguate lower and upper explicit bounds such that
       it reads:

    "R818 <explicit-shape-bounds-spec>
         <<is>> [ <lower-explicit-bounds-expr> : ] <upper-explicit-bounds-expr>
         <<or>> <lower-bound> : <explicit-bounds-expr>
         <<or>> <explicit-bounds-expr> : <upper-bound>

[118:21+] After R818, insert new rules:

    "R818b <lower-explicit-bounds-expr> <<is>> <explicit-bounds-expr>
     R818c <upper-explicit-bounds-expr> <<is>> <explicit-bounds-expr>"

{UTI:  do we need to explain why we did this?}

[121:21] In 8.5.8.6 Implied-shape array, change "the constant-expr in
         its declaration" to "a constant expression".  Such that it now reads:

    "An implied-shape array is a named constant that takes its shape
    from a constant expression."

[121:21] After first sentence, insert new sentence:

     "If it is a deferred constant, it takes its shape from the
      associated instantiation argument, otherwise it takes its shape
      from the constant expression in its declaration."

{Note that this change is a bit larger than strictly necessary.  It is
needed for deferred constants, but it seems natural to include
ordinary constant here.}

[121:27-29] Delete the first sentence of p3 starting with "The extent
            of ...".

[121:30] Change name of section 8.5.8.7 from "Assumed-rank entity" to
         "Assumed-rank or implied-rank entities".

[121:30+] Insert new section heading: 8.5.8.7.1 "Assumed-rank entity"

[121:34] Modify text of the last sentence of p1 change
       "assumed-rank-spec" to "assumed-or-implied-rank-spec", such
       that it now reads:

   "An assumed-rank entity is declared with an <array-spec>
    that is an <assumed-or-implied-rank-spec>.


    R827 assumed-or-implied-rank-spec is ..

    C839 An assumed-rank entity shall be an associate name or a dummy
         data object that does not have the CODIMENSION or VALUE
         attribute.

    C840 An assumed-rank variable name shall not appear in a
         designator or expression except as an actual argument that
         corresponds to a dummy argument that is assumed-rank, the
         argument of the function C_LOC or C_SIZEOF from the intrinsic
         module ISO_C_BINDING (18.2), the first dummy argument of an
         intrinsic inquiry function, or the selector of a SELECT RANK
         statement.

    C841 If an assumed-size or nonallocatable nonpointer assumed-rank
         array is an actual argument that corresponds to a dummy
         argument that is an INTENT (OUT) assumed-rank array, it shall
         not be polymorphic, finalizable, of a type with an
         allocatable ultimate component, or of a type for which
         default initialization is specified.

[122:8+] Insert new section

    "8.5.8.7.2 Implied-rank entity

     An implied-rank entity is an entity whose rank becomes defined
     only within the instantiation of a template.  The following are
     implied-rank entities:

       - deferred constant declared with <assumed-or-implied-rank-spec>

       - variable, dummy argument, or deferred constant whose rank is
         declared to be a deferred integer, scalar constant expression

       - variable, dummy argument, or deferred constant whose shape is
         declared to be a deferred integer, rank-1 array expression.

{UTI: Also make sure it works with SELECT GENERIC RANK and spell out
      what can be done with implied-rank entities.  Contingent on
      edits for auto-generic procedures.}

    NOTE

        The following are examples of implied-rank entities

        TEMPLATE EXAMPLE(C, S, N)
           DEFERRED INTEGER, PARAMETER :: S(*)
           DEFERRED INTEGER, PARAMETER :: C(..) ! implied-rank
           INTEGER, PARAMETER :: B(S) = 1       ! implied-rank
           REAL, PARAMETER, RANK(RANK(C)) :: D  ! implied rank
        END TEMPLATE

[127:3] In 8.5.17 RANK clause, in C864, replace "a dummy data object or" with
        "a named constant, a dummy data object, or" such that it now reads:

    "C864  An entity declared with a rank-clause shall be a named constant,
           dummy data object or have the ALLOCATABLE or POINTER attribute."

{This change is a bit larger than strictly necessary for generic
programming.  We only need to allow it for deferred constants, but it
seems natural to allow for ordinary named constants as well.}

[127:6] In p2, after "it is a deferred-shape array;" insert "
        otherwise, if it is a named constant, it specifies that it is
        an implied-shape array with all lower bounds equal to one;"
        such that the entire sentence reads:


    "If the rank is zero the entity is scalar; otherwise, if it has
    the ALLOCATABLE or POINTER attribute, it specifies that it is a
    deferred-shape array; otherwise, if it is a named constant, it
    specifies that it is an implied-shape array with all lower
    bounds equal to one; otherwise, it specifies that it is an
    assumed-shape array with all the lower bounds equal to one".

[128:36-37] In 8.6.1 Accessibility Statement, in constraint C873, after
            "a module", insert " or template" twice, such that the
            constraint reads:

  "C873 (R831) An <access-stmt> shall appear only in the
        <specification-part> of a module or template. Only one
        accessibility statement with an omitted <access-id-list> is
        permitted in the <specification-part> of a module or
        template."

[129:1-2] In constraint, C874, replace "or namelist group" with
          "namelist-group, requirement, or template" such that the
          entire constraint now reads:
           

   "C874 (R831) Each <access-name> shall be the name of a module,
         variable, procedure, nonintrinsic type, named constant other
         than a deferred constant, namelist group, requirement, or
         template."

[129:7] In second sentence of p1, insert "or template" after "in the
         module" in both locations such that the sentence now reads:

    "An access-stmt without an access-id list specifies the default
    accessibility of the identifiers of entities declared in the
    module or template, and of entities accessed from a module whose
    name does not appear in any access-stmt in the module or
    template."

[129:9] In last sentence of paragraph 1, insert "or template" after
         "in a module" such that the sentence now reads:

    "If no such statement appears in a module or template, the default
    is public accessibility."

[129:16] In first sentence of paragraph 2, insert "or template" after "in
       the module" such that the sentence now reads:

    "If an identifier is accessed by use association and not declared
    in the module or template, and the name of every module from which
    it is accessed appears in an access-stmt in the scoping unit, its
    default accessibility is PRIVATE if the access-spec in every such
    access-stmt is PRIVATE, or PUBLIC if the access-spec in any such
    access-stmt is PUBLIC."

{UTI  deferred args cannot be declared public or private}

{UTI host associated and use associated entities should not be public
in a template}

[136:30-32] In 8.7 IMPLICIT Statement, replace the last sentence of
            paragraph 3 with

   "If a mapping is not specified for a letter, the default mapping of
     - a program unit, or
     - an interface body outside a template scoping unit or templated
       subprogram
    is default integer if the letter is I, J, ..., or N and default real
    otherwise.

    If a mapping is not specified for a letter, the default mapping for
    a BLOCK construct, internal subprogram, or module subprogram is the
    mapping in the host scoping unit.

    The mapping for a template construct, a templated subprogram, or
    an interface body that appears within a template or templated
    subprogram is the null mapping.
   "

[139:7] In section 8.8 IMPORT Statement, in second sentence of p2,
        after "module procedure interface body", insert " or an interface body
        that appears in a deferred interface block."  The sentence will then read:

    "This is the default for an interface body that is not a module
     procedure interface body or an interface body that appears in a
     deferred interface block."

[139:14] In sentence 2 of p4, replace "or submodule" with "submodule,
         or an interface body that appears in a deferred interface
         block", such that it now reads:

    "This is the default for a derived-type definition, internal
     subprogram, module procedure interface body, module subprogram,
     submodule, or an interface body that appears in a deferred
     interface block."

Clause 10: Expressions and  assignment
--------------------------------------

[187:4] In, 10.1.12 Constant expression remove " or" from end of item
        (14), and " or" to end of item (15) and then introduce a new
        item for deferred constant.  The lines should now read:

  (14) an ac-do-variable within an array constructor where each
       scalar-int-expr of the corresponding ac-implied-do-control is
       a constant expression,
  (15) a constant expression enclosed in parentheses, or
  (16) a deferred constant,

{This change is possibly not necessary.  Subgroup is not certain.}

* 10.2.1.2 Intrinsic assignment statement

{UTI Subgroup believes that the existing constraints on intrinsic
assignment in 10.2.1.2 "Intrinsic assigment statement" are sufficient
for the case of intrinsic assignment with deferred rank entities.  But
would appreciate further feedback on this issue.}


Clause 11: Execution control
----------------------------

[225:17+] In section 11.1.11.1 Purpose and form of the SELECT TYPE
          construct, insert entry in R1156 type-guard-stmt:

  "<<or>> CLASS IS ( <deferred-type> ) [ <select-construct-name> ]"

Such that the entire rule becomes:

  "R1156 <type-guard-stmt>
      <<is>> TYPE IS ( <type-spec> ) [ <select-construct-name> ]
      <<or>> CLASS IS ( <derived-type-spec> ) [ <select-construct-name> ]
      <<or>> CLASS IS ( <deferred-type> ) [ <select-construct-name> ]
      <<or>> CLASS DEFAULT [ <select-construct-name> ]"

[226:9+] Add new constraint on R1156 type-guard-statement:

    "C1169b (R1156) <deferred-type> shall specify an extensible type."


Clause 14: Program units
------------------------

[326:12+] In 14.2.1 Module syntax and semantics, add the following
          lines to rule 1408 module-subprogram:

      "<<or>> <templated-function-subprogram>
       <<or>> <templated-subroutine-subprogram>"

  such that the rule now reads:

    "R1408 <module-subprogram>
              <<is>> <function-subprogram>
              <<or>> <subroutine-subprogram>
              <<or>> <separate-module-subprogram>
              <<or>> <templated-function-subprogram>
              <<or>> <templated-subroutine-subprogram>"

[327:2] In section 14.2.2 The USE statement and use assocation,
        replace ", and namelist groups" with " namelist groups,
        templates, and templated procedures" such that the entire
        sentence now reads:

    "The USE statement provides the means by which a scoping unit
    accesses named data objects, nonintrinsic types, procedures,
    abstract interfaces, generic identifiers, namelist groups,
    templates, and templated procedures in a module."


Clause 15: Procedures
---------------------

{UTI: Do we want to include template procedure in section 15.2.2.2
External, internal, and module procedures? }

* 15.4.2.1 Interfaces and scopes

{UTI: first bullet should include template procedure?}

[334:30+] In section 15.4.3.2 Interface block, in rule 1503
          interface-stmt, add a new line:
   
       " <<or>> DEFERRED INTERFACE"

such that the rule now reads:

    "R1503 <interface-stmt> <<is>> INTERFACE [ <generic-spec> ]
                            <<or>> ABSTRACT INTERFACE
                            <<or>> DEFERRED INTERFACE"

{UTI: Need a constraint that only deferred procedures can appear in a
deferred interface block.

[335:23+] Introduce new constraint on rule 1503 interface-stmt:

      "C1503b Each <subroutine-name> or <function-name> of an
       <interface-body> that appears in a deferred interface block
       shall be the name of a deferred argument of the scoping unit in
       which the <interface-body> appears."
}

[336:2] In last sentence of p2, replace "with neither Abstract nor" with "without ABSTRACT, DEF        ERRED, or" such that the sentence now reads:

    "An interface block without ABSTRACT, DEFERRED, or a generic
     specification is a specific interface block."

[336:3+] Insert a new paragraph:

    "An interface block introduced by DEFERRED INTERFACE is a deferred
     interface block. An interface body in a deferred interface block
     specifies a deferred procedure."

[340:8+] In 15.4.3.4.5 Restrictions on generic declarations, insert 4
          new paragraphs and a note:

   
   "The kind of an entity is deferred if the kind depends on the value
    of a deferred argument or depends on a deferred attribute of an
    entity.

    An entity whose kind is deferred only has the same kind as another
    entity if the kind of both entities is declared with syntactically
    equivalent expressions where the declaration is either in the type
    declaration of the entity, or in default kind declaration.

    The rank of an entity is deferred if the rank depends on the value
    of a deferred argument or depends on a deferred attribute of an
    entity.

    An entity whose rank is deferred only has the same rank as another
    entity if: 
      - both entities are declared with the RANK clause with
        syntactically equivalent expressions for the rank,
      - both are declared with syntactically equivalent <array-spec>s, or
      - one entity is declared with a RANKOF clause that references
        the other.
      - the two entities have the same rank as some other entity.

  NOTE Some examples of implied-rank entities are shown in the
       following example template. C is explicitly declared
       as implied-rank. B is implied-rank because its rank depends on
       the size of the deferred argument S. X, Y and Z are implied-rank
       because their ranks depend on the value of the deferred argument N.

    TEMPLATE EXAMPLE(C, S, N)
      DEFERRED INTEGER, PARAMETER :: C(..) ! implied-shape & implied-rank
      DEFERRED INTEGER, PARAMETER :: S(*), N
      INTEGER, PARAMETER :: B(S) = 1 ! explicit-shape & implied-rank
    CONTAINS
      SUBROUTINE SUB(X)
        INTEGER, RANK(N) :: X ! assumed-shape & implied-rank
        INTEGER :: Y([(i, i = 1, N)]) ! explicit-shape & implied-rank
        INTEGER, RANK(N), ALLOCATABLE :: Z ! deferred-shape & implied-rank
        call sub_explicit(C) ! valid, element order association
        ! call sub_assumed(C) ! invalid, rank expressions don't match
        ! call sub_same_rank(C) ! invalid, rank expressions don't match

        call sub_explicit(X) ! valid, element order association
        ! call sub_assumed(X) ! invalid, rank expressions don't match
        call sub_same_rank(X) ! valid, rank expressions match

        call sub_explicit(Y) ! valid, element order association
        ! call sub_assumed(Y) ! invalid, rank expressions don't match
        ! call sub_same_rank(Y) ! invalid, rank expressions don't match
      END SUBROUTINE
      SUBROUTINE SUB_EXPLICIT(X)
        INTEGER :: X(10)
      END SUBROUTINE
      SUBROUTINE SUB_ASSUMED(X)
        INTEGER :: X(:)
      END SUBROUTINE
      SUBROUTINE SUB_SAME_RANK(X)
        INTEGER, RANK(N) :: X
      END SUBROUTINE
    END TEMPLATE"

[344:19+] In section 15.5.1 Syntax of a procedure reference, append
          two new lines to R1522 procedure-designator:

      "  <<or>> <deferred-proc>
         <<or>> <inline-instantiation>"

  such that the rule now reads:

   "R1522 <procedure-designator> <<is>> <procedure-name>
                                 <<or>> <proc-component-ref>
                                 <<or>> <data-ref> % binding-name
                                 <<or>> <deferred-proc>
                                 <<or>> <inline-instantiation>"

[355:5+] Extend R1524 <actual-arg> with <deferred-proc> and
         <inline-instantiation> such that it now reads:

   "R1524 actual-arg <<is>> <expr>
                     <<or>> <variable>
                     <<or>> <procedure-name>
                     <<or>> <proc-component-ref>
                     <<or>> <conditional-arg>
                     <<or>> <alt-return-spec>
                     <<or>> <deferred-proc>
                     <<or>> <inline-instantiation>"

[349:10] In section 15.5.2.5 Ordinary dummy variables, after the first
         sentence of p3, insert a new sentence:

    "If a kind-type parameter of the actual argument or its
     corresponding dummy argument depends on a deferred constant, then
     both shall have syntactically equivalent declarations for that
     kind-type parameter."

{deferred kind}

[350:34+] After p15 introduce a new paragraph to address deferred rank
          entities:

    "If the rank of the actual argument or its corresponding dummy
     argument depend on a deferred constant, then their ranks agree if
     and only if they are declared with syntactically equivalent
     expressions."

{deferred rank}

{UTI:  These changes to 15.5.2.5 may not be necessary.   Other words in new
       15.4.3.4.5 may suffice.}

[363:15+] In section 15.6.2.1 General, append new line to R1530 prefix-spec:

    " <<or>> TEMPLATE "

such that the entire rule now reads:

      "R1530 prefix-spec <<is>> declaration-type-spec
                         <<or>> ELEMENTAL
                         <<or>> IMPURE
                         <<or>> MODULE
                         <<or>> NON_RECURSIVE
                         <<or>> PURE
                         <<or>> RECURSIVE
                         <<or>> SIMPLE
                         <<or>> TEMPLATE


[363:33+] Insert new constraint on R1530:

     "C1560b (R1530) TEMPLATE shall not appear except in a
              <templated-function-stmt> or a
              <templated-subroutine-stmt>."


[365:11] In section 15.6.2.2 Function subprogram, in C1573, after "in
         the end-function-stmt" insert " in function-subprogram" such
         that the constraint now reads:

     "C1573 (R1536) If a function-name appears in the
      end-function-stmt in a function-subprogram , it shall be
      identical to the function name specified in the function-stmt."

[366:15] In section 15.6.2.3 Subroutine subprogram, in C1576, after
         "in the end-subroutine-stmt" insert " in
         subroutine-subprogram" such that the constraint now reads:

     "C1576 (R1540) If a subroutine-name appears in an end-subroutine-stmt in a
      subroutine-subprogram, it shall be identical to the
      subroutine-name specified in the subprogramâ€™s subroutine-stmt."

{Note: A rule is referenced in C1573 but not C1576.  This edit makes
this consistent.}

Clause 16: Intrinsic procedures and modules
-------------------------------------------

* 16.9.57 CO_REDUCE(A,OPERATION,...)

[410:24] After second sentence in Arguments paragraph, insert a new sentence:

      "It shall not be of a deferred type."

 such that the entire paragraph now reads:

     "A   shall not be polymorphic. It shall not be of a type with an
          ultimate component that is alloc atable or a pointer. It
          shall not be of a deferred type.  It shall have the same
          shape, type, and type parameter values, in corres ponding
          references. It shall not be a coindexed object. It is an
          INTENT (INOUT) argument.  If A is scalar, the computed value
          is the result of the reduction operation of applying OPERA
          TION to the values of A in all corresponding references. If
          A is an array, each element of the computed value is equal
          to the result of the reduction operation of applying
          OPERATION to corresponding elements of A in all
          corresponding references.  The computed value is assigned to
          A if no error condition occurs, and either RESULT_IMAGE is
          absent, or the executing image is the one identified by
          RESULT_IMAGE. Otherwise, A becomes undefined."

{UTI:  Need something in 19.5.1 association}


Annex A:
--------

* A.2 Processor Dependencies

[597:43] Replace final period "." with semicolon ";".

[597:43+] Append a new bullet in the list of processor dependencies

    * the names of the dummy arguments of a deferred procedure without
      an explicit specification (tt.8.2.4).

===END===
